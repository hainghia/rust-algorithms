:PROPERTIES:
:ID:       de1c23fa-94b5-4957-91f7-99c229c03a85
:END:
#+title: Algorithms A - Z - Rust

* What is Big O Notation
** Why?
- Đây là phần đâu tiên cũng là phần cơ bản nhất, nhưng đối với Vũ đây là phần
  quang trọng nhất cho bất kỳ lập trình viên nào luôn nâng cao trình độ.
- Bất kể bạn làm việc ở công ty nào, bạn code về gì, thậm chi nếu bạn viết code
  trong 10 năm nữa đây vẫn sẽ là một khái niệm tồn tại trong một thời gian rất
  dài nữa.
- Big O là một kiến thức cực kỳ quang trọng, nó sẽ giúp bạn trở thành một Lập
  trình viên tốt hơn, một engineer tốt hơn.
- Hầu hết các công ty lớn về công ty đều sẽ rất quang tâm tới kiến thức nền
  tảng này, bạn sẽ khó có thể vào được vòng phỏng vấn trong mà không hiểu rõ về
  BigO.
- Vì vậy chúng ta sẽ tìm hiểu rõ về nó ngày =section= đầu tiên.

** What is Big O?
- Big O là một ký hiệu, Big O là dạng =Asymptotic Analysis= ( phân tích tiểm cận )
- Để trở thành một lập trình viên giỏi bạn thường sẽ giải quyết một vấn đề một
  cách tối ưu nhất, vấn đề lớn nhất đó là nó được giải quyết tốt nhứ thế nào!
- Đây là lúc BigO Sẽ giúp chúng ta, nó cho phép to biết ta giải quyết vấn đề tốt
  như thế nào. Chúng ta sẽ cùng tìm hiểu điều này có ý nghĩa là gì trong phần này.
- Chúng ta tìm hiểu BigO ngay đầu tiên vì trong toàn bộ khoá học bạn sẽ thấy O
  xuất hiện rất nhiều.
** What is Good Code?
- Good code là gì?
* How To Solve Coding Problems
** Solve Google Interview Problem
* Data Structures
** What is Data Structures
*** What is?
*** How Computer Store Data?
*** Data Structures khác với Ngôn ngữ lập trình
*** Operations on Data Structures
** Array/Vec/String
*** Static & Dynamic
*** Implementation a Vector/Array
*** Exercise
***** Reverse A String
***** Merge sorted Vector
*** Question Interview
** Hash Tables
*** Introductions
- HashTable Animation
https://www.cs.usfca.edu/~galles/visualization/OpenHash.html
*** Hash Function
*** Hash Collisions
*** Exercise implement a Hash Table
*** keys()
*** Hash Tables & Array/Vec
*** Exercise First Recurring Character
*** Document
** Singly & Doubly Linked Lists
*** Introduction
- What is a Linked Lists.
- [[https://visualgo.net/en/list][Visualization Linked Lists]]
*** Imposter Syndrome
*** Why We Need Linked List?
*** What a Pointer?
*** First Linked List
*** Doubly Linked List
*** Singly & doubly Linked List
*** Reverse()
** Queues
*** What is Stacks?
*** What is Queues?
*** Exercise
*** Queues using Stacks
** Trees (BST, AVL Trees, Red Black Trees, Binary Heaps)
*** Introduction
*** Binary Trees
*** O(log n)
*** B-Tree
*** Segment Tree
*** Fenwick Tree
*** Binary Search Trees
*** Balanced & Unbalanced BST
*** BST Pros & Cons
*** AVL Trees
*** Binary Heaps
*** Priority Queues
*** Union Find
*** Trie
** Graphs
*** Introduction
*** Types of Graphs
*** Guess the Graphs
*** Graphs Data
*** Graph Implementation
* Algorithms
** Recursion
*** Introduction
*** Stack Overflow
*** Anatomy of Recursion
*** Exercies Factorial & Fibonanci
*** Recursive & Iterative
*** When to use Recursive
** Sorting
*** Introduction
*** Issue with sort()
*** Sorting Algorithms
*** Bubble Sort
*** Selection Sort
*** Dancing Algorithms
*** Insertion Sort
*** Merge Sort & O(nlogn)
*** Quick Sort
*** Quick sort is best
*** Radix Sort & Counting Sort
*** Cocktail-shaker
*** Cycle
*** Exchange
*** Gnome
*** Odd-even
*** Pancake
*** Pigeonhole
*** Shell
*** Stooge
*** Comb
*** Bucket
*** Timsort
*** Some Exercise Sorting Interview

** Searching
*** Introduction
*** Traversal Introduction
*** Linear Search
*** Binary Search
*** Graph & Tree Traversals
*** BFS
*** DFS
*** BFS & DFS
*** breadthFirstSearch()
*** breadthFirstSearchRecursive()
*** preOrder, inOrder, postOrder.
*** depthFirstSearch()
*** Graph Traversals
*** BFS in Graph
*** DFS in Graph
*** Dijkstra + Bellman-Ford Algorithms
** Dynamic Programming
*** Introduction
*** Memoization
*** Fibonanci & Dynamic Programming
*** Implementation Dynamic Programming
